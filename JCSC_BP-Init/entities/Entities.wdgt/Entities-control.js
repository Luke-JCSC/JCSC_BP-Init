var s = null; // point to search control
var result = null;
var scroll = null;
var ctr = 0;

function findEntity(event) {
	// clear all the old matched elements
	while (result.content.firstChild) 
		result.content.removeChild(result.content.firstChild);
	
	result.refresh();
	
	if (s.value.length) {
		var like = e.like(s.value);
				
		if (like.length()) {
			showElm(scroll);
			like.each(function(i, last) {
				result.content.appendChild(newRow(this, last));
			}); 
						
			slideDown(function() {
				result.refresh();
			});
		} else {
			slideUp();
		}
	} else {
		slideUp();
	}
}

function slideDown(cb) {
	animate(1, cb);
}

function slideUp(cb) {
	// hide once rolled up (because we have some of the border left over)
	animate(0, function() { hideElm(scroll); });
}

function animate(expand, cb) {
	var animator = new AppleAnimator (150, 3); // 150 = duration, 3 = intervals
	
	if (typeof cb == 'function') {
		animator.oncomplete = function() {
			setTimeout(cb, 0);
		};
	}
	
	// try to work out the best height
	var max = 353;
	var to = max;
	var from = result.lastHeight || 0;
	
	// use the offset of the last element to calculate the height
	if (result.content.lastChild) {
		var lastP = result.content.lastChild; // should return at least 1
		to = lastP.offsetTop + lastP.offsetHeight;
	}
		
	from = expand ? from : to > max ? max : from;
	to = expand ? to > max ? max : to : 0;
	
	// store so we can resize from the last position
	result.lastHeight = to;
	
	var animation = new AppleAnimation(from, to, grow);
	animator.addAnimation(animation);
	animator.start();
}

function grow(animation, now, first, done) {
	window.resizeTo(346, now + 62); // resize the widget
	scroll.style.setProperty('height', now.toString() + 'px'); // resize the scroller
}

function hideElm(elm) {
	if (typeof elm == 'string') 
		document.getElementById(elm).style.setProperty('display', 'none');
	else
		elm.style.setProperty('display', 'none');
}

function showElm(elm) {
	if (typeof elm == 'string') 
		document.getElementById(elm).style.setProperty('display', 'block');
	else
		elm.style.setProperty('display', 'block');
}

function newRow(entity, last) {
	var container = document.createElement('div');
	container.className = last ? 'entity entity-last' : 'entity';
	container.rel = entity.html;
	container.title = 'Click to copy html entity to clipboard';
	container.onclick = copyHTML;
	
	// should really change to DOM methods - but it works just fine
	container.innerHTML = '<div class="html">' + entity.html + '</div><div class="code">' + entity.code + '</div><div class="entityName">' + entity.entity + '</div><div class="code">&amp;' + entity.entity + ';</div><div class="clear"></div><div class="description">' + entity.description + '</div>';
	
	return container;
}

function copyHTML() {
	//osascript -e 'set the clipboard to "words to copy"'
	var cmd = "osascript -e 'set the clipboard to ";
	cmd += '"' + this.rel + '"';
	cmd += "'";
	widget.system(cmd, null);
}


function openLink() {
	widget.openURL('http://leftlogic.com/entity-lookup/');
}


// This file was generated by Dashcode from Apple Computer, Inc.
// You may edit this file to customize your Dashboard widget.

function load()
{
	setupParts();
	s = document.getElementById('search');
	scroll = document.getElementById('scrollArea');
	result = document.getElementById('scrollArea').object;
}

function remove()
{
	// your widget has just been removed from the layer
	// remove any preferences as needed
	// widget.setPreferenceForKey(null, createInstancePreferenceKey("your-key"));
}

function hide()
{
	// your widget has just been hidden stop any timers to
	// prevent cpu usage
}

function show()
{
	// your widget has just been shown.  restart any timers
	// and adjust your interface as needed
}

function showBack(event)
{
	// your widget needs to show the back

	var front = document.getElementById("front");
	var back = document.getElementById("back");

	if (window.widget)
		widget.prepareForTransition("ToBack");

	front.style.display="none";
	back.style.display="block";
	
	if (window.widget)
		setTimeout('widget.performTransition();', 0);
}

function showFront(event)
{
	// your widget needs to show the front

	var front = document.getElementById("front");
	var back = document.getElementById("back");

	if (window.widget)
		widget.prepareForTransition("ToFront");

	front.style.display="block";
	back.style.display="none";
	
	if (window.widget)
		setTimeout('widget.performTransition();', 0);
}

if (window.widget)
{
	widget.onremove = remove;
	widget.onhide = hide;
	widget.onshow = show;
}
